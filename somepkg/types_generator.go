// +build generator

package main

import (
	"bufio"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

// TileGen is a structure used to automatically generate the TileType
// definitions and the GameWorldGrid arrays.  This is used by the
// template to produce Go source code.
type TileGen struct {

	// Timestamp is the time at which the templates were
	// generated. (which is when the go generate command is
	// called)
	Timestamp string

	// Definitions contains the definitions that give meaning the
	// grid.txt file.  The definitions are used to generate a
	// 2-dimensional array of tiles.
	Definitions map[string]string

	// PropertiesMaps each of the tile types to the default
	// properties that it has.
	PropertiesMap map[string]([]string)

	// DefaultProperties is the go code in a string defining a
	// mapping (tile kind) -> (property bitmask)
	DefaultProperties string

	// PropertyNameSet is a unique list of property names.
	PropertyNameSet map[string]bool
}

// ReadmeTemplate is the template for the generated README.md file.
const ReadmeTemplate = `
Tile Types Definitions
----------------------------------------------------------------------
 
Time Generated |
---------------|
{{.Timestamp}} |


This defintion table is generated from tile_types.txt.  Each symbol
corresponds to the Name, which becomes a constant in types.go.  Since
the following symbols have been defined, they can be used in grid.txt
to create game worlds!
 
Symbol | Name 
-------|------ 
{{range $key, $val := .Definitions}}{{$key}} | {{$val}}
{{end}}

`

// CodeTemplate is the template for the automatically generated go
// source code.
const CodeTemplate = `
// Code generated by types_generator.go - DO NOT EDIT.

package somepkg

const (
	_ Kind = iota
	{{range $_, $name := .Definitions}}{{$name}}
	{{end}}
)

const (
	_ Property = (1 << iota) >> 1
	{{range $name, $_ := .PropertyNameSet}}{{$name}}
	{{end}}
)

var DefaultProperty = map[Kind]Property {
{{.DefaultProperties}}
}
`

const (
	filenameTileTypes  = "tile_types.txt"
	filenameGrid       = "grid.txt"
	filenameCodeOutput = "types.go"
	filenameReadme     = "readme.md"
)

var (
	tilegen = &TileGen{
		PropertyNameSet: make(map[string]bool),
	}
)

// reads the file into a string, then calls the parser
func processTileTypesFile() {
	b, err := ioutil.ReadFile(filenameTileTypes)
	if err != nil {
		log.Fatal(err)
	}
	tilegen.Definitions = parseTileDefs(string(b))
}

// The parser that scans line-by-line, converting each valid line into
func parseTileDefs(s string) map[string]string {

	scanner := bufio.NewScanner(strings.NewReader(s))
	m := make(map[string]string)
	propMap := make(map[string]([]string))
	line := ""

	for scanner.Scan() {
		line = scanner.Text()
		line = strings.TrimSpace(line)

		if line == "" {
			continue
		}

		arr := strings.Split(line, " ")

		if len(arr) < 2 {
			continue
		}

		name := capitilizeFirstLetter(arr[1])
		symbol := arr[0]
		m[symbol] = name

		// If there aren't any properties, continue now.
		if len(arr) == 2 {
			propMap[name] = []string{}
			continue
		}

		// If there are, capitilize their names,
		// and add them to the set of all properties.
		proplist := []string{}
		for _, v := range arr[2:] {
			prop := capitilizeFirstLetter(v)
			proplist = append(proplist, prop)
			tilegen.PropertyNameSet[prop] = true
		}
		propMap[name] = proplist
	}
	tilegen.PropertiesMap = propMap
	return m
}

// capitilizing the first letter is needed in order to make the
// TileType an exported value.
func capitilizeFirstLetter(s string) string {
	if s == "" {
		return ""
	}
	first := strings.ToUpper(s[0:1])
	return first + s[1:]
}

// stringifyPropertyList converts the propertymap into a string of go
// code.  If no properties are listed, then it defaults to 0.  If
// there are, then the properties are combined into a bitmask using
// Alternation.
//
// In other words, for each property, the OR operator is appended to
// each property name in the list, except for the very last one.
//
func (tg *TileGen) stringifyPropertyList() {
	s := ""
	for name, list := range tg.PropertiesMap {
		s += "\t" + name + ": "

		switch len(list) {
		case 0:
			s += "0,\n"
			continue

		case 1:
			s += list[0] + ",\n"
			continue
		}

		// For arrays greater than length of 1, we will split
		// off the final element.  the | symbol goes after
		// each element except for the last one.
		arr, last := list[:len(list)-1], list[len(list)-1]

		for _, v := range arr {
			s += v + " | "
		}

		s += last + ",\n"
	}
	tg.DefaultProperties = s
}

func makeTheFile(templ, filename string) {
	t := template.Must(template.New(filename).Parse(templ))
	file, err := os.OpenFile(filename, os.O_CREATE|os.O_RDWR, 0644)
	if err != nil {
		log.Fatal(err)
	}
	os.Truncate(filename, 0)
	t.Execute(file, tilegen)
}

func main() {
	tilegen.Timestamp = time.Now().Format(time.UnixDate)
	processTileTypesFile()
	tilegen.stringifyPropertyList()
	makeTheFile(ReadmeTemplate, filenameReadme)
	makeTheFile(CodeTemplate, filenameCodeOutput)
}
